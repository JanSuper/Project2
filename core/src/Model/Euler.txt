package Model;

import com.mygdx.game.CourseShaper;
import com.mygdx.game.PuttingCourse;

public class EulerSolver extends Solver {

		
		public EulerSolver(String ab) {
			super(ab);
		}
		

	//(Math.round(currentPosX*1000000)!=Math.round(previousPosX*1000000))||(Math.round(currentPosY*1000000))!=(Math.round(previousPosY*1000000))

	/**
	 * @param x Co-ordinate
	 * @param y Co-ordinate
	 * @return Height at Given x, y.
	 */
		public double get_height(double x, double y) {
			return (double)shape.evaluate(new Vector2d(x,y));
			//return (double)(Math.sin(x) + y*y);
		}

	public void NextStep() {
			//each method required per step:
			//it's looping until the current position and the previous position stays the same
			//acceleration never reaches 0, the net acceleration between the previous step and the current step reaches 0 thus the positions does not stepSize, this is the logic i am most unsure about
			//and also why based odd of the formula's and implementation they explained in the appendix mass does not effect the resulting movement
//			do {
				
			
			setNextPositions();
			setSlopes();
			setAcceleration();
			setNextVelocities();	
				
				previousPosX = currentPosX;
				previousPosY = currentPosY;
				currentPosX= nextPosX;
				currentPosY = nextPosY;
//				System.out.println(accelerationX + " "+previousPosX + " " + previousPosY + " "+ currentPosX +" "+ currentPosY);

//			} while ((Math.round(currentPosX*1000000)!=Math.round(previousPosX*1000000))||(Math.round(currentPosY*1000000))!=(Math.round(previousPosY*1000000)));
			//System.out.println(accelerationX + " " + accelerationY + " "+ currentPosX +" "+ currentPosY);

		}
		/**
		 *Euler's method finding the slope
		 */
		private void setSlopes() {
			DzDx = (get_height(currentPosX+stepSize, currentPosY) - get_height(currentPosX, currentPosY))/stepSize;
			DzDy = (get_height(currentPosX, currentPosY+stepSize) - get_height(currentPosX, currentPosY))/stepSize;
			/**if((nextPosX>currentPosX)&&(get_height(nextPosX, currentPosY)>get_height(currentPosX, currentPosY))){
				DzDx = (get_height(currentPosX+stepSize, currentPosY) - get_height(currentPosX, currentPosY))/stepSize;
			}else if((currentPosX>nextPosX)&&(get_height(currentPosX, currentPosY)>get_height(nextPosX, currentPosY))){
				DzDx = (get_height(currentPosX, currentPosY) - get_height(currentPosX-stepSize, currentPosY))/stepSize;
			}else if((nextPosX>currentPosX)&&(get_height(nextPosX, currentPosY)<get_height(currentPosX, currentPosY))){
				DzDx = -((get_height(currentPosX, currentPosY) - get_height(currentPosX+stepSize, currentPosY))/stepSize);
			}else{
				DzDx = -((get_height(currentPosX-stepSize, currentPosY) - get_height(currentPosX, currentPosY))/stepSize);
			}
			if((nextPosY>currentPosY)&&(get_height(currentPosX, nextPosY)>get_height(currentPosX, currentPosY))){
				DzDy = (get_height(currentPosX, currentPosY+stepSize) - get_height(currentPosX, currentPosY))/stepSize;
			}else if((currentPosY>nextPosY)&&(get_height(currentPosX, currentPosY)>get_height(currentPosX, nextPosY))){
				DzDy = (get_height(currentPosX, currentPosY) - get_height(currentPosX, currentPosY-stepSize))/stepSize;
			}else if((nextPosY>currentPosY)&&(get_height(currentPosX, nextPosY)<get_height(currentPosX, currentPosY))){
				DzDy = -((get_height(currentPosX, currentPosY) - get_height(currentPosX, currentPosY+stepSize))/stepSize);
			}else{
				DzDy = -((get_height(currentPosX, currentPosY-stepSize) - get_height(currentPosX, currentPosY))/stepSize);
			}**/

		}
		/**
		 * Setting the acceleration using the formula provided
		 */
		private void setAcceleration() {
			accelerationX = -(double)(g*DzDx) - (double)(mu*g*(currentVelX/(Math.sqrt((currentVelX*currentVelX) + (currentVelY*currentVelY)))));
			accelerationY = -(double)(g*DzDy) - (double)(mu*g*(currentVelY/(Math.sqrt((currentVelX*currentVelX) + (currentVelY*currentVelY)))));
		}
		/**
		 * Setting the next position, after a step, by multiplying the current velocity by the step size
		 */
		private void setNextPositions() {
			nextPosX = currentPosX + currentVelX/fps;
			nextPosY = currentPosY + currentVelY/fps;
		}
		
		/**
		 * Setting the new velocity after a step
		 */
		private void setNextVelocities() {
			currentVelX = currentVelX + accelerationX/fps;
			currentVelY = currentVelY + accelerationY/fps;
			
			if (currentVelX < -vmax) {
				currentVelX = -vmax;
			}
			else if (currentVelX > vmax){
				currentVelX = vmax;
			}
			
			if (currentVelY < -vmax) {
				currentVelY = -vmax;
			}
			else if (currentVelY > vmax){
				currentVelY = vmax;
			}
		}

		
	}
